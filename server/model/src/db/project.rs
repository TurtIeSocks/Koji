//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use super::*;
use sea_orm::entity::prelude::*;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "project")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub name: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::geofence::Entity")]
    Geofence,
}

impl Related<geofence::Entity> for Entity {
    fn to() -> RelationDef {
        geofence_project::Relation::Geofence.def()
    }
    fn via() -> Option<RelationDef> {
        Some(geofence_project::Relation::Project.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub struct Query;

impl Query {
    pub async fn paginate(
        db: &DatabaseConnection,
        page: usize,
        posts_per_page: usize,
        sort_by: project::Column,
        order_by: Order,
    ) -> Result<PaginateResults<Model>, DbErr> {
        let paginator = project::Entity::find()
            .order_by(sort_by, order_by)
            .paginate(db, posts_per_page);
        let total = paginator.num_items_and_pages().await?;

        let results = if let Ok(paginated_results) = paginator.fetch_page(page).await.map(|p| p) {
            paginated_results
        } else {
            vec![]
        };
        let results = future::try_join_all(
            results
                .into_iter()
                .map(|result| Query::get_related_fences(db, result)),
        )
        .await
        .unwrap();

        Ok(PaginateResults {
            results,
            total: total.number_of_items,
            has_prev: total.number_of_pages == page + 1,
            has_next: page + 1 < total.number_of_pages,
        })
    }

    pub async fn get_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        project::Entity::find().all(db).await
    }

    pub async fn get_related_fences(
        db: &DatabaseConnection,
        model: Model,
    ) -> Result<(Model, Vec<NameId>), DbErr> {
        let related = model
            .find_related(geofence::Entity)
            .select_only()
            .column(geofence::Column::Id)
            .column(geofence::Column::Name)
            .into_model::<NameId>()
            .all(db)
            .await?;
        Ok((model, related))
    }

    pub async fn create(db: &DatabaseConnection, new_project: Model) -> Result<Model, DbErr> {
        ActiveModel {
            name: Set(new_project.name.to_owned()),
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        }
        .insert(db)
        .await
    }

    pub async fn get_one(db: &DatabaseConnection, id: u32) -> Result<(Model, Vec<NameId>), DbErr> {
        let record = project::Entity::find_by_id(id).one(db).await?;
        let record = record.unwrap();
        Query::get_related_fences(db, record).await
    }

    pub async fn update(
        db: &DatabaseConnection,
        id: u32,
        new_model: Model,
    ) -> Result<Model, DbErr> {
        let old_model: Option<Model> = project::Entity::find_by_id(id).one(db).await?;
        let mut old_model: ActiveModel = old_model.unwrap().into();
        old_model.name = Set(new_model.name.to_owned());
        old_model.updated_at = Set(Utc::now());
        old_model.update(db).await
    }

    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = project::Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }

    pub async fn search(db: &DatabaseConnection, search: String) -> Result<Vec<Model>, DbErr> {
        Ok(project::Entity::find()
            .filter(Column::Name.like(format!("%{}%", search).as_str()))
            .all(db)
            .await?)
    }
}
