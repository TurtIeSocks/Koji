//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use std::collections::HashMap;

use crate::utils::get_mode_acronym;

use super::*;

use geojson::{self, GeoJson, Geometry};
use sea_orm::{entity::prelude::*, FromQueryResult, Order, QueryOrder, QuerySelect};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "route")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub geofence_id: u32,
    pub name: String,
    pub mode: String,
    pub geometry: Json,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::geofence::Entity",
        from = "Column::GeofenceId",
        to = "super::geofence::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Geofence,
}

impl Related<super::geofence::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Geofence.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, Serialize, Deserialize, FromQueryResult)]
pub struct RouteNoGeometry {
    pub id: u32,
    pub geofence_id: u32,
    pub name: String,
    pub mode: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Paginated {
    pub id: u32,
    pub geofence_id: u32,
    pub name: String,
    pub mode: String,
    pub hops: usize,
}

pub struct Query;

impl Query {
    /// Returns paginated Geofence models
    pub async fn paginate(
        db: &DatabaseConnection,
        page: usize,
        posts_per_page: usize,
        sort_by: Column,
        order_by: Order,
        q: String,
    ) -> Result<PaginateResults<Vec<Paginated>>, DbErr> {
        let paginator = Entity::find()
            .order_by(sort_by, order_by)
            .filter(Column::Name.like(format!("%{}%", q).as_str()))
            .paginate(db, posts_per_page);
        let total = paginator.num_items_and_pages().await?;

        let results: Vec<Paginated> = match paginator.fetch_page(page).await {
            Ok(results) => results,
            Err(err) => {
                println!("Error paginating, {:?}", err);
                vec![]
            }
        }
        .into_iter()
        .map(|model| Paginated {
            id: model.id,
            geofence_id: model.geofence_id,
            name: model.name,
            hops: match Geometry::from_json_value(model.geometry) {
                Ok(geometry) => match geometry.value {
                    geojson::Value::MultiPoint(mp) => mp.len(),
                    _ => 0,
                },
                Err(err) => {
                    println!("[Route] Error unwrapping geometry, {:?}", err);
                    0
                }
            },
            mode: model.mode,
        })
        .collect();

        Ok(PaginateResults {
            results,
            total: total.number_of_items,
            has_prev: total.number_of_pages == page + 1,
            has_next: page + 1 < total.number_of_pages,
        })
    }

    /// Returns all Geofence models in the db
    pub async fn get_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Entity::find().all(db).await
    }

    /// Returns all Geofence models in the db without their features
    pub async fn get_all_no_fences(db: &DatabaseConnection) -> Result<Vec<RouteNoGeometry>, DbErr> {
        Entity::find()
            .select_only()
            .column(Column::Id)
            .column(Column::GeofenceId)
            .column(Column::Name)
            .column(Column::Mode)
            .column(Column::CreatedAt)
            .column(Column::UpdatedAt)
            .order_by(Column::Name, Order::Asc)
            .into_model::<RouteNoGeometry>()
            .all(db)
            .await
    }

    /// Creates a new Geofence model, only used from admin panel when creating a single geofence.
    /// Does not try to remove internal props since they do not exist yet
    pub async fn create(db: &DatabaseConnection, incoming: Model) -> Result<Model, DbErr> {
        let new_fence = Geometry::from_json_value(incoming.geometry);
        match new_fence {
            Ok(new_feature) => {
                let value = GeoJson::Geometry(new_feature).to_json_value();
                ActiveModel {
                    name: Set(incoming.name.to_owned()),
                    geofence_id: Set(incoming.geofence_id),
                    geometry: Set(value),
                    mode: Set(incoming.mode),
                    created_at: Set(Utc::now()),
                    updated_at: Set(Utc::now()),
                    ..Default::default()
                }
                .insert(db)
                .await
            }
            Err(err) => Err(DbErr::Custom(format!(
                "New area did not have valid geometry {:?}",
                err
            ))),
        }
    }

    /// Returns a single Geofence model and it's related projects as tuple
    pub async fn get_one(db: &DatabaseConnection, id: u32) -> Result<Option<Model>, DbErr> {
        Entity::find_by_id(id).one(db).await
    }

    // Updates a Geofence model, removes internally used props
    pub async fn update(
        db: &DatabaseConnection,
        id: u32,
        new_model: Model,
    ) -> Result<Model, DbErr> {
        let old_model: Option<Model> = Entity::find_by_id(id).one(db).await?;
        let new_geometry = Geometry::from_json_value(new_model.geometry);
        if let Ok(new_geometry) = new_geometry {
            let value = GeoJson::Geometry(new_geometry).to_json_value();

            let mut old_model: ActiveModel = old_model.unwrap().into();
            old_model.name = Set(new_model.name.to_owned());
            old_model.geofence_id = Set(new_model.geofence_id);
            old_model.geometry = Set(value);
            old_model.mode = Set(new_model.mode);
            old_model.updated_at = Set(Utc::now());
            old_model.update(db).await
        } else {
            Err(DbErr::Custom("New geometry was not valid".to_string()))
        }
    }

    // Deletes a Geofence model from db
    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }

    /// Returns a feature for a route queried by name
    pub async fn route(
        conn: &DatabaseConnection,
        instance_name: &String,
    ) -> Result<Feature, DbErr> {
        let item = Entity::find()
            .filter(Column::Name.eq(Value::String(Some(Box::new(instance_name.to_string())))))
            .one(conn)
            .await?;
        if let Some(item) = item {
            match Feature::from_json_value(item.geometry) {
                Ok(feat) => Ok(feat),
                Err(err) => {
                    println!("Unable to convert to a feature");
                    Err(DbErr::Custom(format!("{:?}", err)))
                }
            }
        } else {
            Err(DbErr::Custom("Route not found".to_string()))
        }
    }

    pub async fn upsert_from_collection(
        conn: &DatabaseConnection,
        area: FeatureCollection,
        auto_mode: bool,
    ) -> Result<(usize, usize), DbErr> {
        let existing: HashMap<String, RouteNoGeometry> = Query::get_all_no_fences(conn)
            .await?
            .into_iter()
            .map(|model| (format!("{}_{}", model.name, model.mode), model))
            .collect();

        let mut inserts = 0;
        let mut update_len = 0;

        for feat in area.into_iter() {
            if let Some(name) = feat.property("__name") {
                if let Some(name) = name.as_str() {
                    if let Some(mode) = feat.property("__type") {
                        if let Some(mode) = mode.as_str() {
                            let geofence_id = if let Some(fence_id) = feat.property("__geofence_id")
                            {
                                fence_id.as_u64()
                            } else {
                                let geofence = geofence::Entity::find()
                                    .filter(
                                        geofence::Column::Name
                                            .eq(Value::String(Some(Box::new(name.to_string())))),
                                    )
                                    .one(conn)
                                    .await?;
                                if let Some(geofence) = geofence {
                                    Some(geofence.id as u64)
                                } else {
                                    None
                                }
                            };
                            if let Some(fence_id) = geofence_id {
                                if let Some(geometry) = feat.geometry.clone() {
                                    let geometry = GeoJson::Geometry(geometry).to_json_value();
                                    if let Some(geometry) = geometry.as_object() {
                                        let geometry =
                                            sea_orm::JsonValue::Object(geometry.to_owned());
                                        let name = name.to_string();
                                        let mode = mode.to_string();
                                        let name = if auto_mode {
                                            format!("{}_{}", name, get_mode_acronym(Some(&mode)))
                                        } else {
                                            name
                                        };
                                        let is_update = existing.get(&format!("{}_{}", name, mode));
                                        let update_bool = is_update.is_some();

                                        let mut active_model = if let Some(entry) = is_update {
                                            Entity::find_by_id(entry.id)
                                                .one(conn)
                                                .await?
                                                .unwrap()
                                                .into()
                                        } else {
                                            ActiveModel {
                                                ..Default::default()
                                            }
                                        };
                                        active_model.geofence_id = Set(fence_id as u32);
                                        active_model.geometry = Set(geometry);
                                        active_model.mode = Set(mode);
                                        active_model.updated_at = Set(Utc::now());

                                        if update_bool {
                                            active_model.update(conn).await?;
                                            update_len += 1;
                                        } else {
                                            active_model.name = Set(name);
                                            active_model.created_at = Set(Utc::now());
                                            active_model.insert(conn).await?;
                                            inserts += 1;
                                        }
                                    } else {
                                        println!(
                                            "[ROUTE_SAVE] geometry value is invalid for {}",
                                            name
                                        )
                                    }
                                } else {
                                    println!(
                                        "[ROUTE_SAVE] geometry value does not exist for {}",
                                        name
                                    )
                                }
                            } else {
                                println!(
                                    "[ROUTE_SAVE] __geofence_id property not found for {}",
                                    name
                                )
                            }
                        } else {
                            println!(
                                "[ROUTE_SAVE] __mode property is not a valid string for {}",
                                name
                            )
                        }
                    } else {
                        println!("[ROUTE_SAVE] __mode property not found for {}", name)
                    }
                } else {
                    println!(
                        "[ROUTE_SAVE] __name property is not a valid string for {:?}",
                        name
                    )
                }
            } else {
                println!("[ROUTE_SAVE] __name property not found, {:?}", feat.id)
            }
        }
        Ok((inserts, update_len))
    }
}
