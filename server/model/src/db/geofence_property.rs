//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use std::collections::HashMap;

use crate::utils::json::{parse_property_value, JsonToModel};

use super::{sea_orm_active_enums::Category, *};
use sea_orm::{entity::prelude::*, UpdateResult};
use serde_json::json;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "geofence_property")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub geofence_id: u32,
    pub property_id: u32,
    #[sea_orm(column_type = "Text", nullable)]
    pub value: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::geofence::Entity",
        from = "Column::GeofenceId",
        to = "super::geofence::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Geofence,
    #[sea_orm(
        belongs_to = "super::property::Entity",
        from = "Column::PropertyId",
        to = "super::property::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    Property,
}

impl Related<super::geofence::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Geofence.def()
    }
}

impl Related<super::property::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Property.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Basic<'a> {
    pub name: &'a str,
    pub value: Json,
}

#[derive(Clone, Debug, FromQueryResult, Serialize, Deserialize)]
pub struct FullPropertyModel {
    pub id: u32,
    pub geofence_id: u32,
    pub property_id: u32,
    pub name: String,
    pub category: Category,
    pub value: Option<String>,
}

impl FullPropertyModel {
    pub fn parse_db_value(&self, model: &geofence::Model) -> Basic {
        let parsed_value: Json = match self.category {
            Category::Database => match self.name.as_str() {
                "id" => serde_json::Value::from(model.id),
                "name" => serde_json::Value::from(model.name.to_string()),
                "mode" => serde_json::Value::from(model.mode.to_value()),
                "geo_type" => serde_json::Value::from(model.geo_type.to_string()),
                "parent" => serde_json::Value::from(model.parent),
                "created_at" => serde_json::Value::from(model.created_at.to_string()),
                "updated_at" => serde_json::Value::from(model.updated_at.to_string()),
                _ => serde_json::Value::Null,
            },
            _ => {
                if let Some(value) = &self.value {
                    parse_property_value(value, &self.category)
                } else {
                    serde_json::Value::Null
                }
            }
        };
        Basic {
            name: &self.name,
            value: parsed_value,
        }
    }
}

pub struct Query;

impl Query {
    pub async fn upsert(
        db: &DatabaseConnection,
        json: &Json,
        geofence_id: Option<u32>,
    ) -> Result<Model, ModelError> {
        let mut active_model = json.to_geofence_property(geofence_id)?;
        let existing = Entity::find()
            .filter(Column::GeofenceId.eq(active_model.geofence_id.as_ref().clone()))
            .filter(Column::PropertyId.eq(active_model.property_id.as_ref().clone()))
            .one(db)
            .await?;
        let property = property::Entity::find_by_id(active_model.property_id.as_ref().clone())
            .one(db)
            .await?;
        if let Some(property) = property {
            if active_model.value.as_ref().is_none() {
                active_model.value = Set(property.default_value);
            }
            if property.category == Category::Database {
                active_model.value = Set(None);
            }
            Ok(if let Some(existing) = existing {
                active_model.id = Set(existing.id);
                active_model.update(db).await?
            } else {
                active_model.insert(db).await?
            })
        } else {
            Err(ModelError::GeofenceProperty("Invalid Property".to_string()))
        }
    }

    pub async fn update_properties_by_geofence(
        db: &DatabaseConnection,
        incoming: &Vec<Json>,
        geofence_id: Option<u32>,
    ) -> Result<Vec<Model>, ModelError> {
        let mut existing = Entity::find()
            .filter(Column::GeofenceId.eq(geofence_id))
            .all(db)
            .await?
            .into_iter()
            .map(|model| (model.id, false))
            .collect::<HashMap<_, _>>();

        let models = future::try_join_all(
            incoming
                .into_iter()
                .map(|json| Query::upsert(db, json, geofence_id)),
        )
        .await?;

        for model in models.iter() {
            existing.entry(model.id).and_modify(|e| *e = true);
        }

        let existing: Vec<u32> = existing
            .into_iter()
            .filter_map(|(id, exists)| if !exists { Some(id) } else { None })
            .collect();

        if existing.len() > 0 {
            Entity::delete_many()
                .filter(Column::Id.is_in(existing))
                .exec(db)
                .await?;
        }
        Ok(models)
    }

    pub async fn add_db_property(
        db: &DatabaseConnection,
        id: u32,
        prop: &str,
    ) -> Result<Model, ModelError> {
        let property = property::Query::get_or_create_db_prop(db, prop).await?;
        Query::upsert(
            db,
            &json!({ "property_id": property.id, "geofence_id": id, }),
            None,
        )
        .await
    }

    pub async fn update_values_for_property(
        db: &DatabaseConnection,
        property_id: u32,
        new_value: &Option<String>,
    ) -> Result<UpdateResult, DbErr> {
        Entity::update_many()
            .filter(Column::PropertyId.eq(property_id))
            .col_expr(Column::Value, Expr::value(new_value.to_owned()))
            .exec(db)
            .await
    }
}
