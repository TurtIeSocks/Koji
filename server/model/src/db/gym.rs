//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use crate::utils::sql_raw;

use super::*;

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "gym")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: String,
    pub lat: f64,
    pub lon: f64,
    pub name: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub description: Option<String>,
    pub url: Option<String>,
    pub last_modified_timestamp: Option<u32>,
    pub raid_end_timestamp: Option<u32>,
    pub raid_spawn_timestamp: Option<u32>,
    pub raid_battle_timestamp: Option<u32>,
    pub updated: u32,
    pub raid_pokemon_id: Option<u16>,
    pub guarding_pokemon_id: Option<u16>,
    pub available_slots: Option<u16>,
    pub team_id: Option<u8>,
    pub raid_level: Option<u8>,
    pub enabled: Option<u8>,
    pub ex_raid_eligible: Option<u8>,
    pub in_battle: Option<u8>,
    pub raid_pokemon_move_1: Option<u16>,
    pub raid_pokemon_move_2: Option<u16>,
    pub raid_pokemon_form: Option<u16>,
    pub raid_pokemon_cp: Option<u32>,
    pub raid_is_exclusive: Option<u8>,
    pub cell_id: Option<u64>,
    pub deleted: u8,
    pub total_cp: Option<u32>,
    pub first_seen_timestamp: u32,
    pub raid_pokemon_gender: Option<u8>,
    pub sponsor_id: Option<u16>,
    pub partner_id: Option<String>,
    pub raid_pokemon_costume: Option<u16>,
    pub raid_pokemon_evolution: Option<u8>,
    pub ar_scan_eligible: Option<u8>,
    pub power_up_level: Option<u16>,
    pub power_up_points: Option<u32>,
    pub power_up_end_timestamp: Option<u32>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

pub struct Query;

impl Query {
    pub async fn all(conn: &DatabaseConnection, last_seen: u32) -> Result<Vec<GenericData>, DbErr> {
        let items = Entity::find()
            .select_only()
            .column(Column::Lat)
            .column(Column::Lon)
            .filter(Column::Updated.gt(last_seen))
            .filter(Column::Deleted.eq(false))
            .filter(Column::Enabled.eq(true))
            .limit(2_000_000)
            .into_model::<api::point_struct::PointStruct>()
            .all(conn)
            .await?;
        Ok(utils::normalize::fort(items, "g"))
    }

    pub async fn bound(
        conn: &DatabaseConnection,
        payload: &api::args::BoundsArg,
        last_seen: u32,
    ) -> Result<Vec<GenericData>, DbErr> {
        let items = Entity::find()
            .select_only()
            .column(Column::Lat)
            .column(Column::Lon)
            .filter(Column::Lat.between(payload.min_lat, payload.max_lat))
            .filter(Column::Lon.between(payload.min_lon, payload.max_lon))
            .filter(Column::Updated.gt(last_seen))
            .filter(Column::Deleted.eq(false))
            .filter(Column::Enabled.eq(true))
            .limit(2_000_000)
            .into_model::<api::point_struct::PointStruct>()
            .all(conn)
            .await?;
        Ok(utils::normalize::fort(items, "g"))
    }

    pub async fn area(
        conn: &DatabaseConnection,
        area: &FeatureCollection,
        last_seen: u32,
    ) -> Result<Vec<GenericData>, DbErr> {
        let items = Entity::find()
            .from_raw_sql(Statement::from_sql_and_values(
                DbBackend::MySql,
                format!("SELECT lat, lon FROM gym WHERE enabled = 1 AND deleted = 0 AND updated >= {} AND ({}) LIMIT 2000000", last_seen, sql_raw(area)).as_str(),
                vec![],
            ))
            .into_model::<api::point_struct::PointStruct>()
            .all(conn)
            .await?;
        Ok(utils::normalize::fort(items, "g"))
    }

    pub async fn stats(
        conn: &DatabaseConnection,
        area: &FeatureCollection,
        last_seen: u32,
    ) -> Result<Total, DbErr> {
        let items = Entity::find()
            .column_as(Column::Id.count(), "count")
            .from_raw_sql(Statement::from_sql_and_values(
                DbBackend::MySql,
                format!("SELECT COUNT(*) AS total FROM gym WHERE enabled = 1 AND deleted = 0 AND updated >= {} AND ({})", last_seen, utils::sql_raw(area)).as_str(),
                vec![],
            ))
            .into_model::<Total>()
            .one(conn)
            .await?;
        Ok(if let Some(item) = items {
            item
        } else {
            Total { total: 0 }
        })
    }
}
