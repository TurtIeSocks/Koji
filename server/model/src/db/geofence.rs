//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use std::{collections::HashMap, str::FromStr};

use crate::{
    api::{args::ApiQueryArgs, GeoFormats, ToCollection},
    error::ModelError,
    utils::{get_enum, json::JsonToModel, json_related_sort, parse_order},
};

use super::{geofence_property::FullPropertyModel, sea_orm_active_enums::Type, *};

use geojson::{GeoJson, Geometry};
use sea_orm::{entity::prelude::*, InsertResult, UpdateResult};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "geofence")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    #[sea_orm(unique)]
    pub name: String,
    // pub area: Option<Json>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
    pub mode: Type,
    pub geometry: Json,
    pub geo_type: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::project::Entity")]
    Project,
    #[sea_orm(has_many = "super::geofence_property::Entity")]
    GeofenceProperty,
    #[sea_orm(has_many = "super::route::Entity")]
    Route,
}

impl Related<project::Entity> for Entity {
    fn to() -> RelationDef {
        geofence_project::Relation::Project.def()
    }
    fn via() -> Option<RelationDef> {
        Some(geofence_project::Relation::Geofence.def().rev())
    }
}

impl Related<super::geofence_property::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::GeofenceProperty.def()
    }
}

impl Related<super::route::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Route.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Serialize, Deserialize, FromQueryResult)]
pub struct GeofenceNoGeometry {
    pub id: u32,
    pub name: String,
    pub mode: Type,
    pub geo_type: String,
    // pub created_at: DateTimeUtc,
    // pub updated_at: DateTimeUtc,
}

impl Model {
    async fn to_feature(
        self,
        db: &DatabaseConnection,
        internal: bool,
    ) -> Result<Feature, ModelError> {
        let properties = if internal {
            vec![
                json!({ "name": "__id", "value": self.id }),
                json!({ "name": "__name", "value": self.name }),
                json!({ "name": "__mode", "value": self.mode }),
            ]
        } else {
            self.get_related_properties()
                .into_model::<FullPropertyModel>()
                .all(db)
                .await?
                .into_iter()
                .map(|prop| prop.parse_db_value(&self))
                .collect()
        };

        let mut feature = Feature {
            geometry: Some(Geometry::from_json_value(self.geometry)?),
            ..Default::default()
        };
        properties.iter().for_each(|prop| {
            let key = prop.get("name");
            let val = prop.get("value");
            if let Some(key) = key {
                if let Some(key) = key.as_str() {
                    feature.set_property(key, val.unwrap().clone())
                }
            }
        });

        if internal {
            feature.id = Some(geojson::feature::Id::String(format!(
                "{}__{}__KOJI",
                self.id, self.mode
            )));
        }
        Ok(feature)
    }

    fn get_related_projects(&self) -> Select<project::Entity> {
        self.find_related(project::Entity)
            .select_only()
            .column(project::Column::Id)
            .column(project::Column::Name)
    }

    fn get_related_routes(&self) -> Select<route::Entity> {
        self.find_related(route::Entity)
            .select_only()
            .column(route::Column::Id)
            .column(route::Column::Name)
    }

    fn get_related_properties(&self) -> Select<geofence_property::Entity> {
        self.find_related(geofence_property::Entity)
            .join(
                sea_orm::JoinType::Join,
                geofence_property::Relation::Property.def(),
            )
            .select_only()
            .column(geofence_property::Column::Id)
            .column(geofence_property::Column::PropertyId)
            .column(geofence_property::Column::GeofenceId)
            .column(geofence_property::Column::Value)
            .column(property::Column::Name)
            .column(property::Column::Category)
            .filter(geofence_property::Column::GeofenceId.eq(self.id))
    }
}

pub struct Query;

impl Query {
    /// Returns a single Geofence model and it's related projects as tuple
    pub async fn get_one(db: &DatabaseConnection, id: String) -> Result<Model, ModelError> {
        let record = match id.parse::<u32>() {
            Ok(id) => Entity::find_by_id(id).one(db).await?,
            Err(_) => Entity::find().filter(Column::Name.eq(id)).one(db).await?,
        };
        if let Some(record) = record {
            Ok(record)
        } else {
            Err(ModelError::Geofence("Does not exist".to_string()))
        }
    }

    pub async fn get_one_json(db: &DatabaseConnection, id: String) -> Result<Json, ModelError> {
        match Query::get_one(db, id).await {
            Ok(record) => Ok(json!(record)),
            Err(err) => Err(err),
        }
    }

    pub async fn get_one_json_with_related(
        db: &DatabaseConnection,
        id: String,
    ) -> Result<Json, ModelError> {
        match Query::get_one(db, id).await {
            Ok(record) => {
                let mut json = json!(record);
                let json = json.as_object_mut().unwrap();
                if json.contains_key("area") {
                    json.remove("area");
                }
                json.insert(
                    "projects".to_string(),
                    json!(record
                        .get_related_projects()
                        .into_model::<NameId>()
                        .all(db)
                        .await?
                        .into_iter()
                        .map(|p| p.id)
                        .collect::<Vec<u32>>()),
                );
                json.insert(
                    "routes".to_string(),
                    json!(record.get_related_routes().into_json().all(db).await?),
                );
                json.insert(
                    "properties".to_string(),
                    json!(record
                        .get_related_properties()
                        .into_model::<FullPropertyModel>()
                        .all(db)
                        .await?
                        .into_iter()
                        .map(|prop| prop.parse_db_value(&record))
                        .collect::<Vec<Json>>()),
                );
                Ok(json!(json))
            }
            Err(err) => Err(err),
        }
    }

    pub async fn get_one_feature(
        db: &DatabaseConnection,
        id: String,
        args: Option<ApiQueryArgs>,
    ) -> Result<Feature, ModelError> {
        match Query::get_one(db, id).await {
            Ok(record) => record.to_feature(db, args.is_some()).await,
            Err(err) => Err(err),
        }
    }

    /// Returns all Geofence models in the db
    pub async fn get_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Entity::find().all(db).await
    }

    /// Returns all Geofence models in the db
    pub async fn get_all_json(db: &DatabaseConnection) -> Result<Vec<Json>, DbErr> {
        Entity::find().into_json().all(db).await
    }

    /// Returns all geofence models as a FeatureCollection,
    pub async fn get_all_collection(
        db: &DatabaseConnection,
        args: Option<ApiQueryArgs>,
    ) -> Result<FeatureCollection, ModelError> {
        let results = Query::get_all(db).await?;

        let results = future::try_join_all(
            results
                .into_iter()
                .map(|result| result.to_feature(db, args.is_some())),
        )
        .await?;

        Ok(results.to_collection(None, None))
    }

    /// Returns all Geofence models in the db without their features
    pub async fn get_all_no_fences(
        db: &DatabaseConnection,
    ) -> Result<Vec<GeofenceNoGeometry>, DbErr> {
        Entity::find()
            .select_only()
            .column(Column::Id)
            .column(Column::Name)
            .column(Column::Mode)
            .column(Column::GeoType)
            .order_by(Column::Name, Order::Asc)
            .into_model::<GeofenceNoGeometry>()
            .all(db)
            .await
    }

    pub async fn get_json_cache(db: &DatabaseConnection) -> Result<Vec<sea_orm::JsonValue>, DbErr> {
        Ok(Query::get_all_no_fences(db)
            .await?
            .into_iter()
            .map(|x| json!(x))
            .collect())
    }

    /// Returns paginated Geofence models
    pub async fn paginate(
        db: &DatabaseConnection,
        page: u64,
        posts_per_page: u64,
        order: String,
        sort_by: String,
        q: String,
    ) -> Result<PaginateResults<Vec<Json>>, DbErr> {
        let column = Column::from_str(&sort_by).unwrap_or(Column::Name);

        let paginator = Entity::find()
            .order_by(column, parse_order(&order))
            .filter(Column::Name.like(format!("%{}%", q).as_str()))
            .paginate(db, posts_per_page);
        let total = paginator.num_items_and_pages().await?;

        let results = paginator.fetch_page(page).await?;

        let projects = future::try_join_all(
            results
                .iter()
                .map(|result| result.get_related_projects().into_json().all(db)),
        )
        .await?;

        let properties = future::try_join_all(
            results
                .iter()
                .map(|result| result.get_related_properties().into_json().all(db)),
        )
        .await?;

        let routes = future::try_join_all(
            results
                .iter()
                .map(|result| result.get_related_routes().into_json().all(db)),
        )
        .await?;

        let mut results: Vec<Json> = results
            .into_iter()
            .enumerate()
            .map(|(i, fence)| {
                json!({
                    "id": fence.id,
                    "name": fence.name,
                    "mode": fence.mode,
                    "geo_type": fence.geo_type,
                    // "created_at": fence.created_at,
                    // "updated_at": fence.updated_at,
                    "projects": projects[i],
                    "properties": properties[i],
                    "routes": routes[i],
                })
            })
            .collect();

        if sort_by.contains("length") {
            json_related_sort(&mut results, &sort_by.replace(".length", ""), order);
        }

        Ok(PaginateResults {
            results,
            total: total.number_of_items,
            has_prev: total.number_of_pages == page + 1,
            has_next: page + 1 < total.number_of_pages,
        })
    }

    pub async fn upsert_related_routes(
        conn: &DatabaseConnection,
        old_model: &Model,
        new_name: String,
    ) -> Result<UpdateResult, DbErr> {
        route::Entity::update_many()
            .col_expr(route::Column::Name, Expr::value(new_name))
            .filter(route::Column::GeofenceId.eq(old_model.id.to_owned()))
            .filter(route::Column::Name.eq(old_model.name.to_owned()))
            .exec(conn)
            .await
    }

    pub async fn upsert_related_properties(
        db: &DatabaseConnection,
        json: &serde_json::Value,
        geofence_id: u32,
    ) -> Result<(), ModelError> {
        if let Some(properties) = json.get("properties") {
            if let Some(properties) = properties.as_array() {
                geofence_property::Query::update_properties_by_geofence(
                    db,
                    properties,
                    Some(geofence_id),
                )
                .await?;
            };
        };
        Ok(())
    }

    pub async fn upsert_related_projects(
        db: &DatabaseConnection,
        json: &serde_json::Value,
        geofence_id: u32,
    ) -> Result<(), DbErr> {
        if let Some(projects) = json.get("projects") {
            if let Some(projects) = projects.as_array() {
                geofence_project::Query::upsert_related_by_geofence_id(db, projects, geofence_id)
                    .await?;
            };
        };
        Ok(())
    }

    // Updates a Geofence model, removes internally used props
    pub async fn upsert(db: &DatabaseConnection, id: u32, json: Json) -> Result<Model, ModelError> {
        let old_model = Entity::find_by_id(id).one(db).await?;
        let mut new_model = json.to_geofence()?;

        let model = if let Some(old_model) = old_model {
            let name = new_model.name.as_ref();

            if old_model.name.ne(name) {
                Query::upsert_related_routes(db, &old_model, name.clone()).await?;
            };
            new_model.id = Set(old_model.id);
            new_model.update(db).await?
        } else {
            new_model.insert(db).await?
        };
        Query::upsert_related_projects(db, &json, model.id).await?;
        Query::upsert_related_properties(db, &json, model.id).await?;
        Ok(model)
    }

    /// Deletes a Geofence model from db
    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }

    async fn insert_related_projects(
        conn: &DatabaseConnection,
        projects: Vec<u64>,
        id: u32,
    ) -> Result<InsertResult<geofence_project::ActiveModel>, DbErr> {
        let projects: Vec<geofence_project::ActiveModel> = projects
            .into_iter()
            .map(|project| geofence_project::ActiveModel {
                project_id: Set(project as u32),
                geofence_id: Set(id),
                ..Default::default()
            })
            .collect();
        geofence_project::Entity::insert_many(projects)
            .exec(conn)
            .await
    }

    async fn upsert_feature(
        conn: &DatabaseConnection,
        feat: Feature,
        existing: &HashMap<String, u32>,
        inserts_updates: &mut InsertsUpdates<ActiveModel>,
    ) -> Result<(), DbErr> {
        if let Some(name) = feat.property("__name") {
            if let Some(name) = name.as_str() {
                let mut feat = feat.clone();
                feat.id = None;
                let mode = if let Some(r#type) = feat.property("__mode") {
                    if let Some(r#type) = r#type.as_str() {
                        Some(r#type.to_string())
                    } else {
                        None
                    }
                } else {
                    None
                };
                let mode = get_enum(mode);
                let projects: Option<Vec<u64>> = if let Some(projects) = feat.property("__projects")
                {
                    if let Some(projects) = projects.as_array() {
                        Some(
                            projects
                                .iter()
                                .filter_map(|project| {
                                    if let Some(project) = project.as_u64() {
                                        Some(project)
                                    } else {
                                        None
                                    }
                                })
                                .collect(),
                        )
                    } else {
                        None
                    }
                } else {
                    None
                };
                if let Some(geometry) = feat.geometry {
                    let area = GeoJson::Geometry(geometry).to_json_value();
                    if let Some(area) = area.as_object() {
                        let area = sea_orm::JsonValue::Object(area.to_owned());
                        let name = name.to_string();
                        let is_update = existing.get(&name);

                        if let Some(entry) = is_update {
                            let old_model: Option<Model> =
                                Entity::find_by_id(entry.clone()).one(conn).await?;
                            let mut old_model: ActiveModel = old_model.unwrap().into();
                            old_model.geometry = Set(area);
                            old_model.mode = Set(mode);
                            old_model.updated_at = Set(Utc::now());
                            let model = old_model.update(conn).await?;

                            if let Some(projects) = projects {
                                Query::insert_related_projects(conn, projects, model.id).await?;
                            };
                            inserts_updates.updates += 1;
                            Ok(())
                        } else {
                            let model = ActiveModel {
                                name: Set(name.to_string()),
                                geometry: Set(area),
                                mode: Set(mode),
                                created_at: Set(Utc::now()),
                                updated_at: Set(Utc::now()),
                                ..Default::default()
                            }
                            .insert(conn)
                            .await?;

                            if let Some(projects) = projects {
                                Query::insert_related_projects(conn, projects, model.id).await?;
                            };
                            inserts_updates.inserts += 1;
                            Ok(())
                        }
                    } else {
                        let error = format!("[GEOFENCE] unable to serialize the feature: {}", name);
                        log::warn!("{}", error);
                        Err(DbErr::Custom(error))
                    }
                } else {
                    let error = "[GEOFENCE] Couldn't save geofence, geometry is missing";
                    log::warn!("{}", error);
                    Err(DbErr::Custom(error.to_string()))
                }
            } else {
                let error = "[GEOFENCE] Couldn't save area, name property is malformed";
                log::warn!("{}", error);
                Err(DbErr::Custom(error.to_string()))
            }
        } else {
            let error = "[GEOFENCE] Couldn't save area, name not found in GeoJson!";
            log::warn!("{}", error);
            Err(DbErr::Custom(error.to_string()))
        }
    }

    pub async fn upsert_from_geometry(
        conn: &DatabaseConnection,
        area: GeoFormats,
    ) -> Result<(usize, usize), DbErr> {
        let existing = Entity::find()
            .select_only()
            .column(Column::Id)
            .column(Column::Name)
            .into_model::<NameId>()
            .all(conn)
            .await?
            .into_iter()
            .map(|model| (model.name, model.id))
            .collect();

        let mut inserts_updates = InsertsUpdates::<ActiveModel> {
            to_insert: vec![],
            updates: 0,
            inserts: 0,
        };
        match area {
            GeoFormats::Feature(feat) => {
                Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
            }
            feat => {
                let fc = match feat {
                    GeoFormats::FeatureCollection(fc) => fc,
                    geometry => geometry.to_collection(None, None),
                };
                for feat in fc.into_iter() {
                    Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
                }
            }
        }
        Ok((inserts_updates.inserts, inserts_updates.updates))
    }

    /// Returns all geofence models, as features, that are related to the specified project
    pub async fn by_project(
        conn: &DatabaseConnection,
        project_name: String,
        args: Option<ApiQueryArgs>,
    ) -> Result<Vec<Feature>, ModelError> {
        let items = match project_name.parse::<u32>() {
            Ok(id) => {
                Entity::find()
                    .order_by(Column::Name, Order::Asc)
                    .left_join(project::Entity)
                    .filter(project::Column::Id.eq(id))
                    .all(conn)
                    .await?
            }
            Err(_) => {
                Entity::find()
                    .order_by(Column::Name, Order::Asc)
                    .left_join(project::Entity)
                    .filter(project::Column::Name.eq(project_name))
                    .all(conn)
                    .await?
            }
        };

        let items = future::try_join_all(
            items
                .into_iter()
                .map(|result| result.to_feature(conn, args.is_some())),
        )
        .await?;

        Ok(items)
    }
}
