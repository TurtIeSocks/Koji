//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use std::collections::HashMap;

use crate::{
    api::{FeatureHelpers, GeoFormats, ToCollection},
    error::ModelError,
};

use super::*;

use geojson::GeoJson;
use sea_orm::{entity::prelude::*, InsertResult};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "geofence")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub name: String,
    pub area: Json,
    pub mode: Option<String>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::project::Entity")]
    Project,
    #[sea_orm(has_many = "super::route::Entity")]
    Route,
}

impl Related<project::Entity> for Entity {
    fn to() -> RelationDef {
        geofence_project::Relation::Project.def()
    }
    fn via() -> Option<RelationDef> {
        Some(geofence_project::Relation::Geofence.def().rev())
    }
}

impl Related<super::route::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Route.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Serialize, Deserialize, FromQueryResult)]
pub struct GeofenceNoGeometry {
    pub id: u32,
    pub name: String,
    pub mode: Option<String>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

impl ToFeatureFromModel for Model {
    fn to_feature(self) -> Result<Feature, ModelError> {
        let Self {
            area,
            name,
            id,
            mode,
            ..
        } = self;
        let mut feature = Feature::from_json_value(area)?;
        feature.id = Some(geojson::feature::Id::String(format!(
            "{}__{}__KOJI",
            id,
            mode.as_ref().unwrap_or(&"Null".to_string())
        )));
        feature.set_property("__name", name);
        feature.set_property("__id", id);
        feature.set_property("__mode", mode);
        Ok(feature)
    }
}

pub struct Query;

impl Query {
    /// Returns paginated Geofence models
    pub async fn paginate(
        db: &DatabaseConnection,
        page: usize,
        posts_per_page: usize,
        sort_by: Column,
        order_by: Order,
        q: String,
    ) -> Result<PaginateResults<Vec<(GeofenceNoGeometry, Vec<NameId>)>>, DbErr> {
        let paginator = Entity::find()
            .order_by(sort_by, order_by)
            .filter(Column::Name.like(format!("%{}%", q).as_str()))
            .paginate(db, posts_per_page);
        let total = paginator.num_items_and_pages().await?;

        let results = paginator.fetch_page(page).await?;

        let results = future::try_join_all(
            results
                .into_iter()
                .map(|result| Query::get_related_projects(db, result)),
        )
        .await?;

        Ok(PaginateResults {
            results: results
                .into_iter()
                .map(|(fence, related)| {
                    (
                        GeofenceNoGeometry {
                            id: fence.id,
                            name: fence.name,
                            mode: fence.mode,
                            created_at: fence.created_at,
                            updated_at: fence.updated_at,
                        },
                        related,
                    )
                })
                .collect(),
            total: total.number_of_items,
            has_prev: total.number_of_pages == page + 1,
            has_next: page + 1 < total.number_of_pages,
        })
    }

    /// Returns all Geofence models in the db
    pub async fn get_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        Entity::find().all(db).await
    }

    /// Returns all Geofence models in the db without their features
    pub async fn get_all_no_fences(
        db: &DatabaseConnection,
    ) -> Result<Vec<GeofenceNoGeometry>, DbErr> {
        Entity::find()
            .select_only()
            .column(Column::Id)
            .column(Column::Name)
            .column(Column::Mode)
            .column(Column::CreatedAt)
            .column(Column::UpdatedAt)
            .order_by(Column::Name, Order::Asc)
            .into_model::<GeofenceNoGeometry>()
            .all(db)
            .await
    }

    /// Returns a tuple of the input model and all of its related project models
    pub async fn get_related_projects(
        db: &DatabaseConnection,
        model: Model,
    ) -> Result<(Model, Vec<NameId>), DbErr> {
        let related = model
            .find_related(project::Entity)
            .select_only()
            .column(project::Column::Id)
            .column(project::Column::Name)
            .into_model::<NameId>()
            .all(db)
            .await?;
        Ok((model, related))
    }

    /// Creates a new Geofence model, only used from admin panel when creating a single geofence.
    /// Does not try to remove internal props since they do not exist yet
    pub async fn create(db: &DatabaseConnection, incoming: Model) -> Result<Model, DbErr> {
        let new_fence = Feature::from_json_value(incoming.area);
        match new_fence {
            Ok(new_feature) => {
                let value = GeoJson::Feature(new_feature).to_json_value();
                ActiveModel {
                    name: Set(incoming.name.to_owned()),
                    area: Set(value),
                    mode: Set(incoming.mode),
                    created_at: Set(Utc::now()),
                    updated_at: Set(Utc::now()),
                    ..Default::default()
                }
                .insert(db)
                .await
            }
            Err(err) => Err(DbErr::Custom(format!(
                "New area was not a GeoJSON Feature {:?}",
                err
            ))),
        }
    }

    /// Returns a single Geofence model and it's related projects as tuple
    pub async fn get_one(db: &DatabaseConnection, id: u32) -> Result<(Model, Vec<NameId>), DbErr> {
        let record = Entity::find_by_id(id).one(db).await?;
        let record = record.unwrap();
        Query::get_related_projects(db, record).await
    }

    // Updates a Geofence model, removes internally used props
    pub async fn update(
        db: &DatabaseConnection,
        id: u32,
        new_model: Model,
    ) -> Result<Model, DbErr> {
        let old_model = Entity::find_by_id(id).one(db).await?;
        let new_fence = Feature::from_json_value(new_model.area);
        if let Ok(mut new_feature) = new_fence {
            new_feature.remove_internal_props();
            let value = GeoJson::Feature(new_feature).to_json_value();
            let mut old_model: ActiveModel = old_model.unwrap().into();
            old_model.name = Set(new_model.name.to_owned());
            old_model.area = Set(value);
            old_model.mode = Set(new_model.mode);
            old_model.updated_at = Set(Utc::now());
            old_model.update(db).await
        } else {
            Err(DbErr::Custom(
                "New area was not a GeoJSON Feature".to_string(),
            ))
        }
    }

    // Deletes a Geofence model from db
    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }

    // Returns all geofence models as a FeatureCollection,
    pub async fn as_collection(conn: &DatabaseConnection) -> Result<FeatureCollection, DbErr> {
        let items = Entity::find()
            .order_by(Column::Name, Order::Asc)
            .all(conn)
            .await?;
        let items: Vec<Feature> = items
            .into_iter()
            .filter_map(|item| item.to_feature().ok())
            .collect();

        Ok(items.to_collection(None, None))
    }

    /// Returns a feature for a route queried by name
    pub async fn feature_from_name(
        conn: &DatabaseConnection,
        name: &String,
    ) -> Result<Feature, ModelError> {
        let item = Entity::find()
            .filter(Column::Name.eq(Value::String(Some(Box::new(name.to_string())))))
            .one(conn)
            .await?;
        if let Some(item) = item {
            item.to_feature()
        } else {
            Err(ModelError::Database(DbErr::Custom(
                "Geofence not found".to_string(),
            )))
        }
    }

    /// Returns a feature for a route queried by name
    pub async fn feature(conn: &DatabaseConnection, id: u32) -> Result<Feature, ModelError> {
        let item = Entity::find_by_id(id).one(conn).await?;
        if let Some(item) = item {
            item.to_feature()
        } else {
            Err(ModelError::Database(DbErr::Custom(
                "Geofence not found".to_string(),
            )))
        }
    }

    async fn insert_related_projects(
        conn: &DatabaseConnection,
        projects: Vec<u64>,
        id: u32,
    ) -> Result<InsertResult<geofence_project::ActiveModel>, DbErr> {
        let projects: Vec<geofence_project::ActiveModel> = projects
            .into_iter()
            .map(|project| geofence_project::ActiveModel {
                project_id: Set(project as u32),
                geofence_id: Set(id),
                ..Default::default()
            })
            .collect();
        geofence_project::Entity::insert_many(projects)
            .exec(conn)
            .await
    }

    async fn upsert_feature(
        conn: &DatabaseConnection,
        feat: Feature,
        existing: &HashMap<String, u32>,
        inserts_updates: &mut InsertsUpdates<ActiveModel>,
    ) -> Result<(), DbErr> {
        if let Some(name) = feat.property("__name") {
            if let Some(name) = name.as_str() {
                let mut feat = feat.clone();
                feat.id = None;
                let mode = if let Some(r#type) = feat.property("__mode") {
                    if let Some(r#type) = r#type.as_str() {
                        Some(r#type.to_string())
                    } else {
                        None
                    }
                } else {
                    None
                };
                let projects: Option<Vec<u64>> = if let Some(projects) = feat.property("__projects")
                {
                    if let Some(projects) = projects.as_array() {
                        Some(
                            projects
                                .iter()
                                .filter_map(|project| {
                                    if let Some(project) = project.as_u64() {
                                        Some(project)
                                    } else {
                                        None
                                    }
                                })
                                .collect(),
                        )
                    } else {
                        None
                    }
                } else {
                    None
                };
                feat.remove_internal_props();
                feat.id = None;
                let area = GeoJson::Feature(feat).to_json_value();
                if let Some(area) = area.as_object() {
                    let area = sea_orm::JsonValue::Object(area.to_owned());
                    let name = name.to_string();
                    let is_update = existing.get(&name);

                    if let Some(entry) = is_update {
                        let old_model: Option<Model> =
                            Entity::find_by_id(entry.clone()).one(conn).await?;
                        let mut old_model: ActiveModel = old_model.unwrap().into();
                        old_model.area = Set(area);
                        old_model.mode = Set(mode);
                        old_model.updated_at = Set(Utc::now());
                        let model = old_model.update(conn).await?;

                        if let Some(projects) = projects {
                            Query::insert_related_projects(conn, projects, model.id).await?;
                        };
                        inserts_updates.updates += 1;
                        Ok(())
                    } else {
                        let model = ActiveModel {
                            name: Set(name.to_string()),
                            area: Set(area),
                            mode: Set(mode),
                            created_at: Set(Utc::now()),
                            updated_at: Set(Utc::now()),
                            ..Default::default()
                        }
                        .insert(conn)
                        .await?;

                        if let Some(projects) = projects {
                            Query::insert_related_projects(conn, projects, model.id).await?;
                        };
                        inserts_updates.inserts += 1;
                        Ok(())
                    }
                } else {
                    let error = format!("[AREA] unable to serialize the feature: {}", name);
                    log::warn!("{}", error);
                    Err(DbErr::Custom(error))
                }
            } else {
                let error = "[AREA] Couldn't save area, name property is malformed";
                log::warn!("{}", error);
                Err(DbErr::Custom(error.to_string()))
            }
        } else {
            let error = "[AREA] Couldn't save area, name not found in GeoJson!";
            log::warn!("{}", error);
            Err(DbErr::Custom(error.to_string()))
        }
    }

    pub async fn upsert_from_geometry(
        conn: &DatabaseConnection,
        area: GeoFormats,
    ) -> Result<(usize, usize), DbErr> {
        let existing = Entity::find()
            .select_only()
            .column(Column::Id)
            .column(Column::Name)
            .into_model::<NameId>()
            .all(conn)
            .await?
            .into_iter()
            .map(|model| (model.name, model.id))
            .collect();

        let mut inserts_updates = InsertsUpdates::<ActiveModel> {
            to_insert: vec![],
            updates: 0,
            inserts: 0,
        };
        match area {
            GeoFormats::Feature(feat) => {
                Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
            }
            feat => {
                let fc = match feat {
                    GeoFormats::FeatureCollection(fc) => fc,
                    geometry => geometry.to_collection(None, None),
                };
                for feat in fc.into_iter() {
                    Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
                }
            }
        }
        Ok((inserts_updates.inserts, inserts_updates.updates))
    }

    /// Returns all geofence models, as features, that are related to the specified project
    pub async fn by_project(
        conn: &DatabaseConnection,
        project_id: String,
    ) -> Result<Vec<Feature>, DbErr> {
        let items = Entity::find()
            .order_by(Column::Name, Order::Asc)
            .left_join(project::Entity)
            .filter(project::Column::Name.eq(project_id))
            .all(conn)
            .await?;

        let items: Vec<Feature> = items
            .into_iter()
            .map(|item| {
                let feature = Feature::from_json_value(item.area);
                let feature = if feature.is_ok() {
                    feature.unwrap()
                } else {
                    Feature::default()
                };
                feature
            })
            .collect();
        Ok(items)
    }

    // pub async fn migration_helper(conn: &DatabaseConnection) {
    //     match Entity::find()
    //         .from_raw_sql(Statement::from_sql_and_values(
    //             DbBackend::MySql,
    //             r#"SELECT * FROM geofence WHERE JSON_EXTRACT(area, '$.properties') IS NOT NULL"#,
    //             vec![],
    //         ))
    //         .all(conn)
    //         .await
    //     {
    //         Ok(results) => {
    //             println!("Geojsons in old format: {}", results.len())
    //         }
    //         Err(err) => println!("{:?}", err),
    //     }
    // }
}
