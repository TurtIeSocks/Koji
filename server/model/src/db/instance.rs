//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use std::collections::HashMap;

use crate::{
    api::{
        text::TextHelpers, GeoFormats, ToCollection, ToMultiStruct, ToMultiVec, ToPointStruct,
        ToSingleStruct, ToSingleVec,
    },
    error::ModelError,
    utils::get_mode_acronym,
};

use super::{
    sea_orm_active_enums::Type, utils, Feature, InsertsUpdates, NameTypeId, Order, QueryOrder,
    RdmInstanceArea, ToFeatureFromModel,
};

use sea_orm::{
    entity::prelude::*, sea_query::Expr, DbBackend, FromQueryResult, QuerySelect, Set, Statement,
};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "instance")]
pub struct Model {
    #[sea_orm(primary_key)]
    #[serde(skip_deserializing)]
    pub id: u32,
    #[sea_orm(unique)]
    pub name: String,
    pub r#type: Type,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub data: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Debug, Serialize, FromQueryResult)]
pub struct WithGeoType {
    pub id: u32,
    pub name: String,
    pub mode: Type,
    pub geo_type: String,
}

impl ToFeatureFromModel for Model {
    fn to_feature(self) -> Result<Feature, ModelError> {
        let Self {
            id,
            name,
            r#type,
            data,
            ..
        } = self;
        let mut feature = data.parse_scanner_instance(Some(name.clone()), Some(r#type.clone()));
        feature.id = Some(geojson::feature::Id::String(format!(
            "{}__{}__SCANNER",
            id, r#type
        )));
        feature.set_property("__name", name);
        feature.set_property("__mode", r#type.to_string());
        feature.set_property("__id", id);
        Ok(feature)
    }
}

pub struct Query;

impl Query {
    pub async fn all(
        conn: &DatabaseConnection,
        instance_type: Option<String>,
    ) -> Result<Vec<NameTypeId>, DbErr> {
        let instance_type = utils::get_enum(instance_type);
        if let Some(instance_type) = instance_type {
            Entity::find()
                .filter(Column::Type.eq(instance_type))
                .select_only()
                .column(Column::Name)
                .column_as(Column::Type, "mode")
                .order_by(Column::Name, Order::Asc)
                .into_model::<NameTypeId>()
                .all(conn)
                .await
        } else {
            Entity::find()
                .select_only()
                .column(Column::Id)
                .column(Column::Name)
                .column_as(Column::Type, "mode")
                .order_by(Column::Name, Order::Asc)
                .into_model::<NameTypeId>()
                .all(conn)
                .await
        }
    }

    pub async fn get_json_cache(db: &DatabaseConnection) -> Result<Vec<sea_orm::JsonValue>, DbErr> {
        let entries = Entity::find()
            .from_raw_sql(Statement::from_sql_and_values(
                DbBackend::MySql,
                r#"SELECT id, name, type AS mode,
                        CASE 
                            WHEN type = 'leveling' THEN 'Point'
                            WHEN type LIKE 'circle_%' THEN 'MultiPoint'
                            ELSE 'MultiPolygon'
                        END AS geo_type
                        FROM instance
                        ORDER BY name
                    "#,
                vec![],
            ))
            .into_model::<WithGeoType>()
            .all(db)
            .await?;
        Ok(entries.into_iter().map(|entry| json!(entry)).collect())
    }

    pub async fn feature_from_name(
        conn: &DatabaseConnection,
        name: &String,
    ) -> Result<Feature, ModelError> {
        let item = Entity::find()
            .filter(Column::Name.eq(name.trim().to_string()))
            .one(conn)
            .await?;
        if let Some(item) = item {
            item.to_feature()
        } else {
            Err(ModelError::Custom("Instance not found".to_string()))
        }
    }

    pub async fn feature(conn: &DatabaseConnection, id: u32) -> Result<Feature, ModelError> {
        let item = Entity::find_by_id(id).one(conn).await?;
        if let Some(item) = item {
            item.to_feature()
        } else {
            Err(ModelError::Custom("Instance not found".to_string()))
        }
    }

    async fn upsert_feature(
        conn: &DatabaseConnection,
        feat: Feature,
        existing: &HashMap<String, Model>,
        inserts_updates: &mut InsertsUpdates<ActiveModel>,
    ) -> Result<(), DbErr> {
        if let Some(name) = feat.property("__name") {
            if let Some(name) = name.as_str() {
                let mode = if let Some(instance_type) = feat.property("__mode") {
                    if let Some(instance_type) = instance_type.as_str() {
                        utils::get_enum(Some(instance_type.to_string()))
                    } else {
                        utils::get_enum_by_geometry(&feat.geometry.as_ref().unwrap().value)
                    }
                } else {
                    utils::get_enum_by_geometry(&feat.geometry.as_ref().unwrap().value)
                };
                if let Some(mode) = mode {
                    let area = match mode {
                        Type::CirclePokemon
                        | Type::CircleSmartPokemon
                        | Type::CircleRaid
                        | Type::CircleSmartRaid
                        | Type::ManualQuest => {
                            RdmInstanceArea::Single(feat.clone().to_single_vec().to_single_struct())
                        }
                        Type::Leveling => {
                            RdmInstanceArea::Leveling(feat.clone().to_single_vec().to_struct())
                        }
                        Type::AutoQuest | Type::PokemonIv | Type::AutoPokemon | Type::AutoTth => {
                            RdmInstanceArea::Multi(feat.clone().to_multi_vec().to_multi_struct())
                        }
                    };
                    let new_area = json!(area);
                    let id = if let Some(id) = feat.property("__id") {
                        id.as_u64()
                    } else {
                        log::info!(
                            "ID not found, attempting to save by name ({}) and mode ({})",
                            name,
                            mode
                        );
                        None
                    };
                    if let Some(id) = id {
                        let model = Entity::find_by_id(id as u32).one(conn).await?;
                        if let Some(model) = model {
                            let mut data: HashMap<String, Value> =
                                serde_json::from_str(&model.data).unwrap();
                            data.insert("area".to_string(), new_area);

                            if let Ok(data) = serde_json::to_string(&data) {
                                let mut model: ActiveModel = model.into();
                                model.data = Set(data);
                                match model.update(conn).await {
                                    Ok(_) => {
                                        log::info!("Successfully updated {}", id);
                                        Ok(())
                                    }
                                    Err(err) => {
                                        let error = format!("Unable to update {}: {:?}", id, err);
                                        log::error!("{}", error);
                                        Err(DbErr::Custom(error))
                                    }
                                }
                            } else {
                                let error = format!("Unable to serialize json: {:?}", data);
                                log::error!("{}", error);
                                Err(DbErr::Custom(error))
                            }
                        } else {
                            let error = format!(
                                "Found an ID but was unable to find the record in the db: {}",
                                id
                            );
                            log::error!("{}", error);
                            Err(DbErr::Custom(error))
                        }
                    } else {
                        let name = name.to_string();
                        let is_update = existing.get(&name);
                        if let Some(entry) = is_update {
                            if entry.r#type == mode {
                                let mut data: HashMap<String, Value> =
                                    serde_json::from_str(&entry.data).unwrap();
                                data.insert("area".to_string(), new_area);

                                Entity::update_many()
                                    .col_expr(Column::Data, Expr::value(json!(data).to_string()))
                                    .filter(Column::Id.eq(entry.id))
                                    .exec(conn)
                                    .await?;
                                inserts_updates.updates += 1;
                                Ok(())
                            } else if let Some(actual_entry) = existing.get(&format!(
                                "{}_{}",
                                name,
                                get_mode_acronym(Some(&mode.to_string()))
                            )) {
                                let mut data: HashMap<String, Value> =
                                    serde_json::from_str(&actual_entry.data).unwrap();
                                data.insert("area".to_string(), new_area);

                                Entity::update_many()
                                    .col_expr(Column::Data, Expr::value(json!(data).to_string()))
                                    .filter(Column::Name.eq(actual_entry.name.to_string()))
                                    .exec(conn)
                                    .await?;
                                inserts_updates.updates += 1;
                                Ok(())
                            } else {
                                let mut active_model = ActiveModel {
                                    name: Set(name.to_string()),
                                    ..Default::default()
                                };
                                active_model
                                    .set_from_json(json!({
                                        "name": format!("{}_{}", name, get_mode_acronym(Some(&mode.to_string()))),
                                        "type": mode,
                                        "data": json!({ "area": new_area }).to_string(),
                                    }))
                                    .unwrap();

                                inserts_updates.inserts += 1;
                                inserts_updates.to_insert.push(active_model);
                                Ok(())
                            }
                        } else {
                            let mut active_model = ActiveModel {
                                name: Set(name.to_string()),
                                ..Default::default()
                            };
                            active_model
                                .set_from_json(json!({
                                    "name": name,
                                    "type": mode,
                                    "data": json!({ "area": new_area }).to_string(),
                                }))
                                .unwrap();
                            inserts_updates.inserts += 1;
                            inserts_updates.to_insert.push(active_model);
                            Ok(())
                        }
                    }
                } else {
                    let error = format!("Unable to determine mode | {:?}", mode);
                    log::warn!("{}", error);
                    Err(DbErr::Custom(error))
                }
            } else {
                let error = format!(
                    "Name property is not a properly formatted string | {}",
                    name
                );
                log::warn!("{}", error);
                Err(DbErr::Custom(error))
            }
        } else {
            let error = format!(
                "Name not found, unable to save feature {:?}",
                feat.properties
            );
            log::warn!("{}", error);
            Err(DbErr::Custom(error))
        }
    }

    pub async fn upsert_from_geometry(
        conn: &DatabaseConnection,
        area: GeoFormats,
        _auto_mode: bool,
    ) -> Result<(usize, usize), DbErr> {
        let existing: HashMap<String, Model> = Entity::find()
            .all(conn)
            .await?
            .into_iter()
            .map(|model| (model.name.to_string(), model))
            .collect();
        let mut inserts_updates = InsertsUpdates::<ActiveModel> {
            inserts: 0,
            updates: 0,
            to_insert: vec![],
        };

        match area {
            GeoFormats::Feature(feat) => {
                Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
            }
            feat => {
                let fc = match feat {
                    GeoFormats::FeatureCollection(fc) => fc,
                    geometry => geometry.to_collection(None, None),
                };
                for feat in fc.into_iter() {
                    Query::upsert_feature(conn, feat, &existing, &mut inserts_updates).await?
                }
            }
        }
        if !inserts_updates.to_insert.is_empty() {
            Entity::insert_many(inserts_updates.to_insert)
                .exec(conn)
                .await?;
        }
        Ok((inserts_updates.inserts, inserts_updates.updates))
    }
}
