//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use crate::{
    api::args::AdminReqParsed,
    utils::{
        json::{parse_property_value, JsonToModel},
        parse_order,
    },
};

use super::{sea_orm_active_enums::Category, *};
use sea_orm::entity::prelude::*;
use serde_json::json;
use std::str::FromStr;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "property")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub name: String,
    pub category: Category,
    #[sea_orm(column_type = "Text", nullable)]
    pub default_value: Option<String>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::geofence_property::Entity")]
    GeofenceProperty,
}

impl Related<super::geofence_property::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::GeofenceProperty.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub struct Query;

impl Query {
    pub async fn paginate(
        db: &DatabaseConnection,
        args: AdminReqParsed,
    ) -> Result<PaginateResults<Vec<Json>>, DbErr> {
        let column = Column::from_str(&args.sort_by).unwrap_or(Column::Name);

        let paginator = property::Entity::find()
            .order_by(column, parse_order(&args.order))
            .filter(Column::Name.like(format!("%{}%", args.q).as_str()))
            .paginate(db, args.per_page);
        let total = paginator.num_items_and_pages().await?;

        let results: Vec<Model> = paginator.fetch_page(args.page).await?;

        let geofences = future::try_join_all(
            results
                .iter()
                .map(|result| result.find_related(geofence_property::Entity).all(db)),
        )
        .await?;

        let results: Vec<Json> = results
            .into_iter()
            .enumerate()
            .map(|(i, fence)| {
                json!({
                    "id": fence.id,
                    "name": fence.name,
                    "category": fence.category,
                    "default_value": if let Some(value) = fence.default_value {
                        parse_property_value(&value, &fence.category)
                    } else {
                        serde_json::Value::Null
                    },
                    // "created_at": fence.created_at,
                    // "updated_at": fence.updated_at,
                    "geofences": geofences[i],
                })
            })
            .collect();

        Ok(PaginateResults {
            results,
            total: total.number_of_items,
            has_prev: total.number_of_pages == args.page + 1,
            has_next: args.page + 1 < total.number_of_pages,
        })
    }

    pub async fn get_all(db: &DatabaseConnection) -> Result<Vec<Model>, DbErr> {
        property::Entity::find().all(db).await
    }

    pub async fn get_json_cache(db: &DatabaseConnection) -> Result<Vec<sea_orm::JsonValue>, DbErr> {
        let results = Entity::find()
            .order_by(Column::Name, Order::Asc)
            .all(db)
            .await?
            .into_iter()
            .map(|record| json!(record))
            .collect();
        Ok(results)
    }

    pub async fn get_one(db: &DatabaseConnection, id: String) -> Result<Model, ModelError> {
        let record = match id.parse::<u32>() {
            Ok(id) => Entity::find_by_id(id).one(db).await?,
            Err(_) => Entity::find().filter(Column::Name.eq(id)).one(db).await?,
        };
        if let Some(record) = record {
            Ok(record)
        } else {
            Err(ModelError::Geofence("Does not exist".to_string()))
        }
    }

    pub async fn get_one_json(db: &DatabaseConnection, id: String) -> Result<Json, ModelError> {
        match Query::get_one(db, id).await {
            Ok(record) => Ok(json!(record)),
            Err(err) => Err(err),
        }
    }

    pub async fn upsert(
        db: &DatabaseConnection,
        id: u32,
        new_model: Json,
    ) -> Result<Model, ModelError> {
        let old_model = Entity::find_by_id(id).one(db).await?;
        let mut new_model = new_model.to_property()?;

        let old_model = if old_model.is_some() {
            old_model
        } else {
            Entity::find()
                .filter(Column::Name.eq(new_model.name.as_ref()))
                .filter(Column::Category.eq(new_model.category.as_ref().clone()))
                .one(db)
                .await?
        };
        let model = if let Some(old_model) = old_model {
            let category = new_model.category.as_ref();

            if old_model.category.ne(category) {
                geofence_property::Query::update_values_for_property(
                    db,
                    id,
                    new_model.default_value.as_ref(),
                )
                .await?;
            };
            new_model.id = Set(old_model.id);
            new_model.update(db).await?
        } else {
            new_model.insert(db).await?
        };
        Ok(model)
    }

    pub async fn upsert_json_return(
        db: &DatabaseConnection,
        id: u32,
        json: Json,
    ) -> Result<Json, ModelError> {
        let result = Query::upsert(db, id, json).await?;
        Ok(json!(result))
    }

    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = property::Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }

    pub async fn get_or_create_db_prop(
        db: &DatabaseConnection,
        prop: &str,
    ) -> Result<Model, DbErr> {
        let record = Entity::find()
            .filter(property::Column::Name.eq(prop))
            .filter(property::Column::Category.eq("database"))
            .one(db)
            .await?;
        if let Some(record) = record {
            Ok(record)
        } else {
            ActiveModel {
                name: Set(prop.to_string()),
                category: Set(Category::Database),
                ..Default::default()
            }
            .insert(db)
            .await
        }
    }

    pub async fn search(db: &DatabaseConnection, search: String) -> Result<Vec<Json>, DbErr> {
        Ok(Entity::find()
            .filter(Column::Name.like(format!("%{}%", search).as_str()))
            .into_json()
            .all(db)
            .await?)
    }
}
