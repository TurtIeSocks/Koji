//! SeaORM Entity. Generated by sea-orm-codegen 0.10.1

use super::{project, PaginateResults, Utc};
use sea_orm::{entity::prelude::*, DeleteResult, Order, QueryOrder, Set};
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "project")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: u32,
    pub name: String,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::geofence::Entity")]
    Geofence,
}

impl Related<super::geofence::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Geofence.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::geofence_project::Relation::Geofence.def().rev())
    }
}

impl ActiveModelBehavior for ActiveModel {}

pub struct Query;

impl Query {
    pub async fn paginate(
        db: &DatabaseConnection,
        page: usize,
        posts_per_page: usize,
        sort_by: project::Column,
        order_by: Order,
    ) -> Result<PaginateResults<Model>, DbErr> {
        let paginator = project::Entity::find()
            .order_by(sort_by, order_by)
            .paginate(db, posts_per_page);
        let total = paginator.num_items_and_pages().await?;

        let results = if let Ok(stuff) = paginator.fetch_page(page).await.map(|p| p) {
            stuff
        } else {
            vec![]
        };
        Ok(PaginateResults {
            results,
            total: total.number_of_items,
            has_prev: total.number_of_pages == page + 1,
            has_next: page + 1 < total.number_of_pages,
        })
    }
    pub async fn create(db: &DatabaseConnection, new_project: Model) -> Result<Model, DbErr> {
        let active_model = ActiveModel {
            name: Set(new_project.name.to_owned()),
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
            ..Default::default()
        };
        project::Entity::insert(active_model)
            .exec_with_returning(db)
            .await
    }
    pub async fn get_one(db: &DatabaseConnection, id: u32) -> Result<Option<Model>, DbErr> {
        let record = project::Entity::find_by_id(id).one(db).await?;
        Ok(record)
    }
    pub async fn update(
        db: &DatabaseConnection,
        id: u32,
        updated_project: Model,
    ) -> Result<Model, DbErr> {
        let old_project: Option<Model> = project::Entity::find_by_id(id).one(db).await?;
        let mut old_project: ActiveModel = old_project.unwrap().into();
        old_project.name = Set(updated_project.name.to_owned());
        old_project.update(db).await
    }
    pub async fn delete(db: &DatabaseConnection, id: u32) -> Result<DeleteResult, DbErr> {
        let record = project::Entity::delete_by_id(id).exec(db).await?;
        Ok(record)
    }
}
